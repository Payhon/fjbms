# 富嘉BMS查询协议2025-V251023
深圳富嘉科技版权所有

## 变更履历表
| 变更日期 | 版本 | 变更内容 | 变更人 | 确认 |
| --- | --- | --- | --- | --- |
| 2025.7.1 | V1.0 | - | - | - |
| 2025.10.10 | V1.1 | 变更充放电延时单位为秒，增加MAC地址查询等 | - | - |
| 2025.10.16 | V1.2 | 修正参数配置高低字节描述反的问题 | - | - |

## 蓝牙BLE UUID1（BMS板支持）
- SERVICE UUID: 0000ffc0-0000-1000-8000-00805f9b34fb
- write without response characteristic UUID: 0000ff03-0000-1000-8000-00805f9b34fb
- notify characteristic UUID: 0000ffC1-0000-1000-8000-00805f9b34fb

## 一、文档适用范围
本文档描述了电脑（或基站主机）与BMS的通信协议（CAN、RS485或RS232、UART），目的用于控制BMS实现电压、电流和温度的保护功能，电池的检测功能。
- 通信设置默认：9600 N 8 1
- 每个寄存器数据长度为16位，数据采用大端模式，无效数据用FF填充

## 二、UART串口参数
| Parameter | Value |
| --- | --- |
| Baudrate | 9600 bps |
| Parity | None |
| Stopbits | 1 |
| Byte size | 8 bits |
| Xon/Xoff | No |
| Hardware flow control | None |

### 备注
1. 波特率会因项目不同存在差异；
2. TimeOut: 200ms；
3. Interval time of the frame: >100 mS；
4. 上位机地址默认为0xFE；
5. CRC值为CRC16-Modbus算法，是从目标地址到CRC前面所有字节的校验值。

## 三、指令格式
### 3.1 读指令
#### 主机发送
| 名称 | 偏移 | 长度 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| 头码 | 0 | 2 | 0x7F, 0x55 | - |
| 来源地址 | 2 | 1 | 上位机0xFE | - |
| 目标地址 | 3 | 1 | 1-254: 从机地址；0: 广播地址；0XFF: 未分配到从机地址的特殊从机地址 | - |
| 功能码 | 4 | 1 | 3（寄存器查询） | - |
| 起始地址 | 5 | 2 | 起始地址高字节、起始地址低字节 | - |
| 寄存器数量=N | 7 | 2 | 寄存器数量高字节、寄存器数量低字节 | - |
| CRC | 9 | 2 | CRCL、CRCH | - |
| 尾码 | 11 | 1 | 0xFD | - |

#### 从机回复
| 名称 | 偏移 | 长度 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| 头码 | 0 | 2 | 0x7F, 0x55 | - |
| 来源地址 | 2 | 1 | 1-253: 从机地址；0: 广播地址；0XFF: 未分配到从机地址的特殊从机地址 | - |
| 目标地址 | 3 | 1 | 同主机发送的一致 | - |
| 功能码 | 4 | 1 | 同主机功能码一致 | - |
| 字节数量=N | 5 | 1 | 字节数量 | 最大250 |
| 数据内容 | 6 | N*2 | [...] | 如果回复数据为0xff，忽略数据内容 |
| CRC | N*2+6 | 2 | CRCL、CRCH | - |
| 尾码 | N*2+8 | 1 | 0xFD | - |

### 3.3 写指令
#### 主机发送
| 名称 | 偏移 | 长度 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| 头码 | 0 | 2 | 0x7F, 0x55 | - |
| 来源地址 | 2 | 1 | 0xFE | - |
| 目标地址 | 3 | 1 | 1-254: 从机地址；0: 广播地址；0XFF: 未分配到从机地址的特殊从机地址 | - |
| 功能码 | 4 | 1 | 0X10（写连续寄存器）、0X11（写从机地址分配地址） | - |
| 起始地址 | 5 | 2 | 起始地址高字节、起始地址低字节 | - |
| 寄存器数量=N | 7 | 2 | 寄存器数量高字节、寄存器数量低字节 | 1~120 |
| 数据字节数量 | 9 | 1 | 字节数量 = N*2 | - |
| 数据内容 | 10 | N*2 | 数据 | - |
| CRC | 11+N*2 | 2 | CRCL、CRCH | - |
| 尾码 | 12+N*2 | 1 | 0xFD | - |

#### 从机回复
| 名称 | 偏移 | 长度 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| 头码 | 0 | 2 | 0x7F, 0x55 | - |
| 来源地址 | 2 | 1 | 1-254: 从机地址；0: 广播地址；0XFF: 未分配到从机地址的特殊从机地址 | - |
| 目标地址 | 3 | 1 | 0xFE | - |
| 功能码 | 4 | 1 | 同主机发送的一致 | - |
| 寄存器地址 | 5 | 2 | 寄存器地址高字节、寄存器地址低字节 | - |
| 寄存器数量 | 7 | 2 | 寄存器数量高字节、寄存器数量低字节 | - |
| CRC | 9 | 2 | CRCL、CRCH | - |
| 尾码 | 10 | 1 | 0xFD | - |

#### 错误回复
| 名称 | 偏移 | 长度 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| 头码 | 0 | 2 | 0x7F, 0x55 | - |
| 来源地址 | 2 | 1 | 1-254: 从机地址；0: 广播地址；0XFF: 未分配到从机地址的特殊从机地址 | - |
| 目标地址 | 3 | 1 | 0xFE | - |
| 功能码 | 4 | 1 | 功能码+0x80 | - |
| 错误代码 | 5 | 1 | 0x01（非法功能码）、0x02（非法地址）、0x03（非法操作） | - |
| CRC | 6 | 2 | CRCL、CRCH | - |
| 尾码 | 8 | 1 | 0xFD | - |

### 3.3 从机主动上报

#### 从机主动上报
| 名称 | 偏移 | 长度 | 描述 | 备注 |
| --- | --- | --- | --- | --- |
| 头码 | 0 | 2 | 0x7F, 0x55 | - |
| 来源地址 | 2 | 1 | 1-253: 从机地址；0: 广播地址；0XFF: 未分配到从机地址的特殊从机地址 | - |
| 目标地址 | 3 | 1 | 同主机发送的一致 | - |
| 功能码 | 4 | 1 | F | F为主动上报 |
| 字节数量=N | 5 | 1 | 字节数量 | 最大250 |
| 数据内容 | 6 | N*2 | [...] | 头 4 个字节为上报的寄存器地址和寄存器数量，后面的字节为上报的数据内容 |
| CRC | N*2+6 | 2 | CRCL、CRCH | - |
| 尾码 | N*2+8 | 1 | 0xFD | - |


## 四、主要状态寄存器
| 地址 | 名称 | 字节描述 | 字节长度 | 读/写 | 单位 | 偏移量 | 分辨率 | 描述 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0x100 | 电池串数、电芯温度数量 | H：电池串数（以下用S表示）；L：电芯温度数量（以下用N表示） | 1+1 | R | - | - | / | - |
| 0x101 | 硬件版本号、软件版本号 | H：硬件版本号；L：软件版本号 | 1+1 | R | - | - | 0.1 | 0~255 |
| 0x102 | 特殊识别符、协议版本号 | H：特殊识别符；L：协议版本号 | 1+1 | R | - | - | 1 | 0~255，特别定义的识别符 |
| 0x103~0x104 | 设计容量 | - | 4 | R | - | - | 1mAh | - |
| 0x105~0x106 | 剩余容量 | - | 4 | R | - | - | 1mAh | - |
| 0x107~0x108 | 满充容量 | - | 4 | R | - | - | 1mAh | - |
| 0x109~0x10A | 满充WH | - | 4 | R | - | - | 0.1WH | - |
| 0x10B~0X10C | SOE(剩余WH) | - | 4 | R | - | - | 0.1WH | - |
| 0X10D | 剩余容量比、健康度 | H：SOC（剩余容量比）；L：SOH（健康度） | 1+1 | R | - | - | 0.5%/Bit、1%/Bit | - |
| 0X10E | 循环次数 | - | 2 | R | - | - | - | 放电电量累计总电量的80%（可设定），计数一次 |
| 0X10F | 最长充电间隔 | - | 2 | R | 小时 | - | 1Hour/Bit | - |
| 0X110 | 当前充电间隔 | - | 2 | R | 小时 | - | 1Hour/Bit | - |
| 0x111 | 放电剩余时间 | - | 2 | R | min | - | - | - |
| 0x112 | 充电剩余时间 | - | 2 | R | min | - | - | - |
| 0x113 | 充电次数 | - | 2 | R | - | - | - | 放电后充电10分钟以上计数1次 |
| 0x114 | 放电次数 | - | 2 | R | - | - | - | 充电后放电10分钟以上计数1次 |
| 0x115 | 电池组总电压 | - | 2 | R | V | - | 0.1V/Bit | 单节累计总压 |
| 0x116 | VBat电压 | - | 2 | R | V | - | 0.1V/Bit | 电池总电压 |
| 0x117 | VPack电压 | - | 2 | R | V | - | 0.1V/Bit | Pack口电压 |
| 0x118 | VLoad电压 | - | 2 | R | V | - | 0.1V/Bit | 充电口电压 |
| 0x119~11A | 电池组电流 | - | 4 | R | A | - | 0.1mA/Bit | 放电为负，充电为正 |
| 0x11B | 均衡状态1~16 | - | 2 | R | - | - | - | 0~16串均衡状态 |
| 0x11C | 均衡状态17~32 | - | 2 | R | - | - | - | 17~32串均衡状态 |
| 0x11D | 充电MOS温度、放电MOS温度 | H：充电MOS温度；L：放电MOS温度 | 1+1 | R | ℃ | -40 | - | - |
| 0x11E | 预充MOS温度、环境温度 | H：预充MOS温度；L：环境温度 | 1+1 | R | ℃ | -40 | - | - |
| 0x11F | 加热膜温度、极柱温度 | H：加热膜温度；L：极柱温度 | 1+1 | R | ℃ | -40 | - | - |
| 0x120~121 | BMS时间 | - | 4 | R | - | timestamp | - | - |
| 0x122 | 最高电压 | - | 2 | R | - | - | 1mV/Bit | - |
| 0x123 | 最低电压 | - | 2 | R | - | - | 1mV/Bit | - |
| 0x124 | 平均电压 | - | 2 | R | - | - | 1mV/Bit | - |
| 0X125 | 最大压差 | - | 2 | R | - | - | 1mV/Bit | - |
| 0x126 | 最高温度 | 高字节：序号；低字节：温度 | 2 | R | ℃ | -40 | - | - |
| 0x127 | 最低温度 | 高字节：序号；低字节：温度 | 2 | R | ℃ | -40 | - | - |
| 0X128 | 最高/最低电压电芯编号 | 高字节：最高；低字节：最低 | 2 | R | - | - | - | - |
| 0X129~0X12A | 上电工作时间 | - | 4 | R | - | - | Hour/Bit | - |
| 0X12B~0X12C | 总充容量 | - | 4 | R | - | - | - | - |
| 0X12D~0X12E | 保护状态 | - | 4 | R | - | - | - | BIT30：总压过压保护；BIT29：总压欠压保护；BIT28：加热膜温度保护；BIT27：温差保护；Bit26：压差保护；Bit25：充满保护；BIT24：充电MOS高温保护；Bit23：放电MOS高温保护；Bit22：保留；Bit21：电芯高温保护；Bit20：电芯低温保护；bit19：放电低温保护(电芯)；bit18：充电低温保护(电芯)；Bit9：单体过放二级保护；Bit8：单体过压二级保护；bit7：绝缘保护；bit6：短路保护；bit5：放电过流一级保护；bit4：充电过流一级保护；bit2：极柱高温保护；BIT14：环境NTC采集失效；Bit3：防反MOS失效；bit1：放电MOS故障；bit0：充电MOS故障 |
| 0X132~0X133 | 指示状态1 | - | 4 | R | - | - | - | Bit31：倍电流较准状态；Bit30：零电流较准状态；Bit29：电压较准状态；Bit28：BMS板注册状态；Bit27：保留；Bit26：DTED接入状态；Bit23：CIN+接入状态；BIT22：保留；BIT21：保留；Bit20：放电握手状态(放电允许)；Bit19：充电握手状态(充电允许)；bit18：加热膜开启指示；bit17：GPS电源指示；bit16：充电器压差检测状态；bit13：振动传感状态；bit12：通讯DCDC输出指示；Bit11：保留；Bit10：保留；Bit9：防反FET开关指示；Bit8：预充FET开关指示；Bit7：放电FET开关指示；Bit6：充电FET开关指示；Bit5：放电限流指示；Bit4：充电限流指示；bit3：回馈充电状态；bit1：充电状态指示；bit0：放电状态指示 |
| 0X134~0X135 | 告警状态1 | - | 4 | R | - | - | - | bit19~bit31：预留；bit18：绝缘告警；Bit17：温差告警；bit16：压差告警；bit15：放电过流告警；bit14：充电过流告警；bit13：总压低压告警；bit12：总压过压告警；bit11：单体低压告警；bit10：单体过压告警；bit9：低电量告警；BIT8：充电MOS高温告警；bit7：放电MOS高温告警；bit6：环境低温告警；bit5：环境高温告警；bit4：热失控告警；bit3：放电及静置低温告警(电芯)；bit2：充电低温告警(电芯)；bit1：放电及静置高温告警(电芯)；bit0：充电高温告警(电芯) |
| 0X136~0X137 | 自订义状态 | - | 4 | R | - | - | - | 其它未定义状态 |
| 0X138 | 生产日期 | - | 2 | R | - | - | - | 年[9:15]+月[5:8]+日[0:4] |
| 0X139 | 自订义参数[8] | - | 16 | R | - | - | - | - |
| 0X141~(0X141+S-1) | 电芯电压[S] | - | 2*S | R | - | - | 1mv/bit | - |
| ... | 电芯温度[N] | - | 2*N | R | K | - | 0.1 | 25度即值为250+2731 |
| ... | 硬件型号 | - | 32 | R | - | - | - | - |
| ... | 电池组编号 | - | 32 | R | - | - | - | 最大32个字符，不足补0 |
| ... | BMS板编码 | - | 32 | R | - | - | - | 最大32个字符，不足补0 |
| ... | 蓝牙MAC地址 | - | 10 | R | - | - | - | 全为FF或0X00为无效，一般为6BYTE |

> 注：...表示地址按数量顺延

## 附：CRC算法
```c
static const uint8_t aucCRCHi[] = {
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0xC0,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40
};

static const uint8_t aucCRCLo[] = {
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
0x6C, 0xAC, 0xAD, 0x6D, 0xAF,
0x6F,
0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8,
0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2,
0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
0x41, 0x81, 0x80, 0x40
};

uint16_t CRC16(uint8_t* pucFrame, uint16_t usLen) {
    uint8_t ucCRCHi = 0xFF;
    uint8_t ucCRCLo = 0xFF;
    int iIndex;
    while (usLen--) {
        iIndex = ucCRCLo ^ *(pucFrame++);
        ucCRCLo = (uint8_t)(ucCRCHi ^ aucCRCHi[iIndex]);
        ucCRCHi = aucCRCLo[iIndex];
    }
    return (uint16_t)(ucCRCHi << 8 | ucCRCLo);
}
```

# 富嘉 BMS 查询协议（补充说明）

本部分基于上诉文档梳理，重点补充“**动态寄存器地址**”的计算方式，便于实现 BLE/串口通讯。

## 1. 核心概念

### 1.1 `S` 与 `N`

寄存器 `0x100` 的高/低字节分别表示：

- `S`：电池串数（电芯数量）
- `N`：电芯温度数量

> 原文：`0x100 | 电池串数、电芯温度数量 | H：电池串数(S)；L：电芯温度数量(N)`

由于后续表格中存在数组字段（例如电芯电压 `[S]`、电芯温度 `[N]`），所以很多字段的**起始寄存器地址不是固定值**，而是需要先读出 `S/N` 后再计算。

## 2. 动态地址计算（最重要）

### 2.1 固定区（固定起始地址）

状态寄存器固定区：`0x100 ~ 0x140`（文档中 `0x139` 起有自定义参数等，整体仍可视为固定区）。

### 2.2 变长区（从 `0x141` 开始按顺序顺延）

从 `0x141` 开始，字段按顺序连续排布（文档用 `...` 表示“地址按数量顺延”）：

1. 电芯电压数组 `[S]`
2. 电芯温度数组 `[N]`
3. 硬件型号（32 bytes = 16 regs）
4. 电池组编号（32 bytes = 16 regs）
5. BMS 板编码（32 bytes = 16 regs）
6. 蓝牙 MAC 地址（10 bytes = 5 regs，通常前 6 bytes 有效）

### 2.3 推荐的起始地址计算公式

以寄存器（16-bit）为单位，定义：

- `CELL_VOLTAGES_START = 0x141`
- `CELL_TEMPS_START = CELL_VOLTAGES_START + S`
- `HW_MODEL_START = CELL_TEMPS_START + N`
- `BATTERY_GROUP_ID_START = HW_MODEL_START + 16`
- `BOARD_CODE_START = BATTERY_GROUP_ID_START + 16`
- `BLUETOOTH_MAC_START = BOARD_CODE_START + 16`

对应字段长度：

- `硬件型号`：从 `HW_MODEL_START` 开始读取 `16 regs`（32 bytes ASCII，末尾用 `0x00` 补零）
- `电池组编号`：从 `BATTERY_GROUP_ID_START` 开始读取 `16 regs`
- `BMS 板编码`：从 `BOARD_CODE_START` 开始读取 `16 regs`
- `蓝牙 MAC`：从 `BLUETOOTH_MAC_START` 开始读取 `5 regs`（10 bytes；全 `0x00` 或全 `0xFF` 视为无效；一般取前 6 bytes）

## 3. “UUID” 与 “BMS板编码” 的区别（容易混淆）

原始文档中有两种“唯一标识”概念：

1. **BMS 板 UUID（功能码 0xFF）**：属于“指令功能”，按读指令格式发 `functionCode=0xFF`，返回 16 字节。
2. **BMS 板编码（状态区动态地址字段）**：在状态寄存器表中（长度 32 字符），地址需要按 `S/N` 动态计算（`BOARD_CODE_START`）。

实际业务侧需要哪个字段，取决于后端/产品定义；若产品要求“唯一编码=板编码”，则应读取 `BOARD_CODE_START` 对应的 32 字符字段。

## 4. CRC 计算说明（与文档一致）

CRC16-Modbus 的计算范围按原文：

- **从“目标地址”开始，到 CRC 前的所有字节**
- 不包含头码 `7F 55`、不包含 CRC 自身与尾码 `FD`

## 5. 实现建议（BLE）

- 连接后建议等待 `200ms` 再进行首个读写（部分设备需要准备时间）。
- 大包读取（例如一次读取 120 寄存器=240 bytes）在部分安卓机型上可能出现分包不完整导致超时，建议拆分为多次小包读取（例如每次 40~60 寄存器）。
