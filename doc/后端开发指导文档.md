# ThingsPanel 后端开发指导文档

## 1. 开发环境搭建

### 1.1 环境要求

- **Golang**: 1.23.0+
- **PostgreSQL**: 12+
- **Redis**: 6.0+
- **MQTT Broker**: GMQTT或VerneMQ
- **Git**: 最新版本
- **IDE**: VS Code / GoLand（推荐）

### 1.2 安装步骤

#### 1.2.1 克隆项目

```bash
git clone <repository-url>
cd fjbms/backend
```

#### 1.2.2 安装依赖

```bash
go mod download
```

#### 1.2.3 配置文件

复制配置文件模板：
```bash
cp configs/conf.yml configs/conf-dev.yml
```

编辑 `configs/conf-dev.yml`，配置数据库、Redis、MQTT等信息：

```yaml
db:
  psql:
    host: 127.0.0.1
    port: 5432
    dbname: ThingsPanel
    username: postgres
    password: your_password
    time_zone: Asia/Shanghai

db:
  redis:
    addr: 127.0.0.1:6379
    db: 1
    password: "your_redis_password"

mqtt:
  broker: 127.0.0.1:1883
  user: root
  pass: root
```

#### 1.2.4 初始化数据库

执行SQL脚本：
```bash
psql -U postgres -d ThingsPanel -f sql/1.sql
psql -U postgres -d ThingsPanel -f sql/2.sql
# ... 依次执行所有SQL文件
```

或者使用Docker快速部署：
```bash
# 使用docker-compose
git clone https://github.com/ThingsPanel/thingspanel-docker.git
cd thingspanel-docker
docker-compose up -d
```

#### 1.2.5 启动服务

```bash
# 开发模式
go run main.go -config ./configs/conf-dev.yml

# 或者使用 Make 命令（如果有 Makefile）
make run-dev
```

## 2. 项目结构详解

### 2.1 目录结构

```
backend/
├── cmd/                    # 命令行工具和辅助程序
│   └── iot-platform-autotest/  # 自动化测试工具
├── configs/               # 配置文件目录
│   ├── conf.yml          # 生产配置
│   ├── conf-dev.yml      # 开发配置
│   └── rsa_key/          # RSA密钥
├── docs/                 # Swagger文档
├── files/                # 文件存储目录
│   └── logs/            # 日志文件
├── initialize/           # 初始化模块
│   ├── casbin.go        # Casbin权限初始化
│   ├── db.go            # 数据库初始化
│   ├── logger.go        # 日志初始化
│   └── redis.go         # Redis初始化
├── internal/             # 核心业务代码
│   ├── adapter/         # 适配器层（数据转换）
│   ├── api/             # HTTP API控制器
│   ├── app/             # 应用层（服务编排）
│   ├── dal/             # 数据访问层
│   ├── diagnostics/     # 诊断服务
│   ├── downlink/        # 下行数据流
│   ├── logic/           # 业务逻辑
│   ├── middleware/      # 中间件
│   ├── model/           # 数据模型
│   ├── processor/       # 数据处理器
│   ├── query/           # GORM Gen生成的查询代码
│   ├── service/         # 服务层
│   ├── storage/         # 存储层
│   └── uplink/          # 上行数据流
├── mqtt/                # MQTT服务
├── pkg/                 # 公共包
│   ├── common/          # 通用工具
│   ├── errcode/         # 错误码定义
│   └── utils/           # 工具函数
├── router/              # 路由配置
│   ├── apps/           # 各模块路由
│   └── router_init.go  # 路由初始化
├── sql/                 # SQL脚本
│   ├── 1.sql           # 基础表结构
│   ├── 2.sql           # 增量更新
│   └── ...
├── static/              # 静态文件
├── test/                # 测试文件
├── third_party/         # 第三方依赖
├── go.mod               # Go模块定义
├── go.sum               # 依赖版本锁定
└── main.go              # 主入口文件
```

### 2.2 核心模块说明

#### 2.2.1 Application层 (`internal/app/`)

应用层负责服务的组装和生命周期管理：

```go
// application.go
type Application struct {
    Config         *viper.Viper      // 配置管理
    Logger         *logrus.Logger    // 日志管理
    DB             *gorm.DB          // 数据库连接
    RedisClient    *redis.Client     // Redis客户端
    ServiceManager *ServiceManager   // 服务管理器
    
    // 各种服务
    storageService   storage.Storage
    uplinkService    *UplinkServiceWrapper
    mqttService      *MQTTService
    downlinkService  *DownlinkServiceWrapper
}
```

使用选项模式初始化：
```go
application, err := app.NewApplication(
    app.WithConfigFile(*configPath),
    app.WithLogger(),
    app.WithDatabase(),
    app.WithRedis(),
    app.WithStorageService(),
    app.WithMQTTService(),
    // ...
)
```

#### 2.2.2 Service层 (`internal/service/`)

服务层包含业务逻辑处理：

**主要服务：**
- `device.go` - 设备管理服务
- `device_config.go` - 设备配置服务
- `device_model.go` - 设备模型服务
- `telemetry_data.go` - 遥测数据服务
- `user.go` - 用户管理服务
- `alarm.go` - 告警服务
- `scene_automations.go` - 自动化服务
- `ota.go` - OTA升级服务

**编写规范：**
```go
type DeviceService struct {
    // 依赖注入
}

func (s *DeviceService) CreateDevice(ctx context.Context, req *CreateDeviceReq) error {
    // 1. 参数验证
    // 2. 业务逻辑处理
    // 3. 数据持久化
    // 4. 返回结果
}
```

#### 2.2.3 API层 (`internal/api/`)

API层负责HTTP请求处理：

```go
// device.go
type DeviceApi struct {
    deviceService *service.DeviceService
}

// @Summary 创建设备
// @Description 创建新设备
// @Tags 设备管理
// @Accept json
// @Produce json
// @Param body body CreateDeviceReq true "设备信息"
// @Success 200 {object} Response
// @Router /api/v1/device [post]
func (a *DeviceApi) CreateDevice(c *gin.Context) {
    var req CreateDeviceReq
    if err := c.ShouldBindJSON(&req); err != nil {
        // 错误处理
        return
    }
    
    // 调用服务层
    err := a.deviceService.CreateDevice(c, &req)
    // 返回响应
}
```

#### 2.2.4 Model层 (`internal/model/`)

数据模型定义，包含数据库表结构和HTTP请求/响应结构：

**数据库模型（.gen.go）：**
```go
// devices.gen.go - 由GORM Gen生成
type Device struct {
    ID           string    `json:"id" gorm:"primaryKey"`
    Name         string    `json:"name"`
    DeviceNumber string    `json:"device_number"`
    TenantID     string    `json:"tenant_id"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
    // ...
}
```

**HTTP模型（.http.go）：**
```go
// devices.http.go
type CreateDeviceReq struct {
    Name         string `json:"name" binding:"required"`
    DeviceNumber string `json:"device_number"`
    // ...
}

type DeviceResponse struct {
    ID   string `json:"id"`
    Name string `json:"name"`
    // ...
}
```

#### 2.2.5 Query层 (`internal/query/`)

GORM Gen生成的查询代码，提供类型安全的数据库查询：

```go
// 使用示例
device := query.Device

// 查询单条记录
dev, err := device.WithContext(ctx).
    Where(device.ID.Eq(deviceID)).
    First()

// 查询列表
devices, err := device.WithContext(ctx).
    Where(device.TenantID.Eq(tenantID)).
    Find()

// 复杂查询
devices, err := device.WithContext(ctx).
    Where(device.TenantID.Eq(tenantID)).
    Where(device.Status.Eq("online")).
    Order(device.CreatedAt.Desc()).
    Limit(10).
    Find()
```

#### 2.2.6 Storage层 (`internal/storage/`)

存储层负责数据批量入库和性能优化：

```go
type Storage interface {
    Start() error
    Stop() error
    SendMessage(msg *Message) error
}

type Message struct {
    DeviceID string
    Key      string
    Value    interface{}
    Timestamp time.Time
}
```

#### 2.2.7 Uplink/Downlink (`internal/uplink/`, `internal/downlink/`)

消息总线架构，处理设备上行和下行数据：

**Uplink（上行）：**
```go
// 设备数据上报流程
MQTT → Uplink Bus → Processor → Storage → Database
                  ↓
              规则引擎/告警
```

**Downlink（下行）：**
```go
// 命令下发流程
API → Downlink Bus → MQTT Publisher → 设备
```

## 3. 开发流程

### 3.1 新增API接口

#### 步骤1：定义数据模型

在 `internal/model/` 中创建/编辑 `.http.go` 文件：

```go
// internal/model/my_feature.http.go
type CreateMyFeatureReq struct {
    Name        string `json:"name" binding:"required"`
    Description string `json:"description"`
}

type MyFeatureResponse struct {
    ID          string    `json:"id"`
    Name        string    `json:"name"`
    Description string    `json:"description"`
    CreatedAt   time.Time `json:"created_at"`
}
```

#### 步骤2：实现Service层

在 `internal/service/` 中创建服务：

```go
// internal/service/my_feature.go
type MyFeatureService struct{}

func NewMyFeatureService() *MyFeatureService {
    return &MyFeatureService{}
}

func (s *MyFeatureService) Create(ctx context.Context, req *model.CreateMyFeatureReq) (*model.MyFeatureResponse, error) {
    // 业务逻辑
    return &model.MyFeatureResponse{}, nil
}
```

#### 步骤3：实现API层

在 `internal/api/` 中创建API处理函数：

```go
// internal/api/my_feature.go
type MyFeatureApi struct {
    myFeatureService *service.MyFeatureService
}

// @Summary 创建功能
// @Tags 我的功能
// @Accept json
// @Produce json
// @Param body body model.CreateMyFeatureReq true "请求参数"
// @Success 200 {object} model.MyFeatureResponse
// @Router /api/v1/my-feature [post]
func (a *MyFeatureApi) Create(c *gin.Context) {
    var req model.CreateMyFeatureReq
    if err := c.ShouldBindJSON(&req); err != nil {
        // 错误处理
        return
    }
    
    result, err := a.myFeatureService.Create(c, &req)
    if err != nil {
        // 错误处理
        return
    }
    
    c.JSON(200, result)
}
```

#### 步骤4：注册路由

在 `router/apps/` 中创建路由文件：

```go
// router/apps/my_feature.go
func InitMyFeatureRouter(r *gin.RouterGroup) {
    api := &api.MyFeatureApi{
        myFeatureService: service.NewMyFeatureService(),
    }
    
    r.POST("/my-feature", api.Create)
    r.GET("/my-feature/:id", api.Get)
    r.PUT("/my-feature/:id", api.Update)
    r.DELETE("/my-feature/:id", api.Delete)
}
```

在 `router/router_init.go` 中注册：

```go
func InitRouter() *gin.Engine {
    r := gin.Default()
    
    v1 := r.Group("/api/v1")
    {
        apps.InitMyFeatureRouter(v1)
    }
    
    return r
}
```

#### 步骤5：生成Swagger文档

```bash
swag init
```

### 3.2 数据库操作

#### 3.2.1 使用Query层

推荐使用GORM Gen生成的Query层：

```go
import "project/internal/query"

func GetDevice(ctx context.Context, deviceID string) (*model.Device, error) {
    d := query.Device
    return d.WithContext(ctx).
        Where(d.ID.Eq(deviceID)).
        First()
}
```

#### 3.2.2 复杂查询

```go
// 联表查询
func GetDeviceWithConfig(ctx context.Context, deviceID string) (*DeviceWithConfig, error) {
    d := query.Device
    dc := query.DeviceConfig
    
    var result DeviceWithConfig
    err := d.WithContext(ctx).
        Select(d.ALL, dc.ALL).
        LeftJoin(dc, d.DeviceConfigID.EqCol(dc.ID)).
        Where(d.ID.Eq(deviceID)).
        Scan(&result)
    
    return &result, err
}
```

#### 3.2.3 事务处理

```go
func CreateDeviceWithConfig(ctx context.Context, req *CreateDeviceReq) error {
    return query.Q.Transaction(func(tx *query.Query) error {
        // 创建设备
        device := &model.Device{
            ID:   uuid.New().String(),
            Name: req.Name,
        }
        if err := tx.Device.WithContext(ctx).Create(device); err != nil {
            return err
        }
        
        // 创建配置
        config := &model.DeviceConfig{
            DeviceID: device.ID,
            // ...
        }
        if err := tx.DeviceConfig.WithContext(ctx).Create(config); err != nil {
            return err
        }
        
        return nil
    })
}
```

### 3.3 MQTT消息处理

#### 3.3.1 订阅主题

在 `mqtt/` 目录中添加订阅处理：

```go
func SubscribeToTopic() {
    client.Subscribe("devices/telemetry", 0, func(client mqtt.Client, msg mqtt.Message) {
        // 处理消息
        payload := msg.Payload()
        // 解析并处理
    })
}
```

#### 3.3.2 发布消息

```go
func PublishCommand(deviceNumber, command string) error {
    topic := fmt.Sprintf("devices/command/%s", deviceNumber)
    token := client.Publish(topic, 1, false, command)
    return token.Error()
}
```

### 3.4 缓存使用

#### 3.4.1 Redis基本操作

```go
import "github.com/redis/go-redis/v9"

// 设置缓存
func SetCache(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    return redisClient.Set(ctx, key, value, expiration).Err()
}

// 获取缓存
func GetCache(ctx context.Context, key string) (string, error) {
    return redisClient.Get(ctx, key).Result()
}

// 删除缓存
func DelCache(ctx context.Context, key string) error {
    return redisClient.Del(ctx, key).Err()
}
```

#### 3.4.2 设备状态缓存

```go
// 设置设备在线状态
func SetDeviceOnline(ctx context.Context, deviceID string) error {
    key := fmt.Sprintf("device:status:%s", deviceID)
    return redisClient.Set(ctx, key, "online", 5*time.Minute).Err()
}
```

### 3.5 权限控制

使用Casbin进行权限管理：

```go
// 检查权限
func CheckPermission(userID, path, method string) (bool, error) {
    enforcer, _ := casbin.NewEnforcer("configs/rbac_model.conf", "configs/rbac_policy.csv")
    return enforcer.Enforce(userID, path, method)
}

// 添加权限
func AddPermission(role, path, method string) error {
    enforcer, _ := casbin.NewEnforcer("configs/rbac_model.conf", "configs/rbac_policy.csv")
    _, err := enforcer.AddPolicy(role, path, method)
    return err
}
```

## 4. 测试

### 4.1 单元测试

创建测试文件（`*_test.go`）：

```go
package service

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestCreateDevice(t *testing.T) {
    // 初始化测试环境
    // 执行测试
    // 断言结果
    assert.NotNil(t, result)
}
```

运行测试：
```bash
go test ./...
```

### 4.2 API测试

使用Swagger UI或Postman进行API测试：

1. 启动服务
2. 访问 `http://localhost:9999/swagger/index.html`
3. 测试API接口

## 5. 调试技巧

### 5.1 日志调试

使用logrus进行日志输出：

```go
import "github.com/sirupsen/logrus"

logrus.Debug("调试信息")
logrus.Info("普通信息")
logrus.Warn("警告信息")
logrus.Error("错误信息")
logrus.WithFields(logrus.Fields{
    "deviceID": deviceID,
    "status":   status,
}).Info("设备状态更新")
```

### 5.2 性能分析

使用pprof进行性能分析：

```go
import _ "net/http/pprof"

go func() {
    http.ListenAndServe(":6060", nil)
}()
```

访问 `http://localhost:6060/debug/pprof/` 查看性能数据

## 6. 常见问题

### 6.1 数据库连接失败

- 检查PostgreSQL是否启动
- 检查配置文件中的数据库连接信息
- 检查网络连接

### 6.2 Redis连接失败

- 检查Redis是否启动
- 检查Redis密码配置
- 检查端口是否正确

### 6.3 MQTT连接失败

- 检查MQTT Broker是否启动
- 检查用户名密码
- 检查端口配置

### 6.4 编译错误

```bash
# 清理缓存
go clean -modcache

# 重新下载依赖
go mod download

# 更新依赖
go mod tidy
```

## 7. 最佳实践

### 7.1 错误处理

统一错误处理：

```go
import "project/pkg/errcode"

func SomeFunction() error {
    if err != nil {
        return errcode.WithData(errcode.CodeDeviceNotFound, 
            map[string]interface{}{"deviceID": deviceID})
    }
    return nil
}
```

### 7.2 参数验证

使用validator进行参数验证：

```go
type CreateDeviceReq struct {
    Name   string `json:"name" binding:"required,min=1,max=100"`
    Number string `json:"number" binding:"required,alphanum"`
}
```

### 7.3 并发控制

使用协程池控制并发：

```go
import "github.com/panjf2000/ants"

pool, _ := ants.NewPool(10)
defer pool.Release()

for _, item := range items {
    pool.Submit(func() {
        // 处理任务
    })
}
```

### 7.4 配置管理

使用Viper管理配置：

```go
import "github.com/spf13/viper"

// 读取配置
dbHost := viper.GetString("db.psql.host")
dbPort := viper.GetInt("db.psql.port")
```

## 8. 部署

### 8.1 编译

```bash
# Linux
GOOS=linux GOARCH=amd64 go build -o thingspanel main.go

# Windows
GOOS=windows GOARCH=amd64 go build -o thingspanel.exe main.go

# macOS
GOOS=darwin GOARCH=amd64 go build -o thingspanel main.go
```

### 8.2 Docker部署

```dockerfile
FROM golang:1.23-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o thingspanel main.go

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/thingspanel .
COPY --from=builder /app/configs ./configs
CMD ["./thingspanel", "-config", "./configs/conf.yml"]
```

构建镜像：
```bash
docker build -t thingspanel-backend .
```

## 9. 性能优化

### 9.1 数据库优化

- 使用连接池
- 添加索引
- 批量操作
- 使用缓存

### 9.2 并发优化

- 使用协程池
- 避免goroutine泄漏
- 使用channel控制并发

### 9.3 内存优化

- 及时释放资源
- 使用对象池
- 避免内存泄漏

## 10. 安全建议

### 10.1 认证授权

- 使用JWT Token
- 实现Token刷新机制
- 密码使用bcrypt加密

### 10.2 SQL注入防护

- 使用参数化查询
- 使用ORM框架

### 10.3 XSS防护

- 输入验证
- 输出编码

### 10.4 CSRF防护

- 使用CSRF Token
- 验证Referer

---

**文档版本**: v1.0  
**最后更新**: 2025-12-01
